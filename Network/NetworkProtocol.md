## 网络协议

### TLS 安全协商（建立在 TCP 三次握手之上）

- 浏览器内置了大量受信任的 Root CA（根证书），可以验证服务器发送的证书是否可信。服务器的数字证书一般由受信任的 CA 签发，客户端可以通过内置证书链验证服务器端的证书。

- **TCP 三次握手（建立连接）**
  ```
  客户端                                          服务器
  ① SYN →                  ---------------->
     (seq=x, 请求建立连接)
                            <----------------  ② SYN-ACK ←
                                               (seq=y, ack=x+1, 同意连接)
  ③ ACK →                  ---------------->
     (ack=y+1, 确认连接)
  
  ✅ TCP 连接建立成功，可以开始传输数据
  ```
  
  **说明：**
  - **SYN (Synchronize)** - 同步序列号，请求建立连接
  - **ACK (Acknowledgment)** - 确认号，确认收到数据
  - **seq** - 序列号，用于数据排序和去重
  - **三次握手目的** - 确认双方收发能力正常，协商初始序列号

- **TCP 四次挥手（关闭连接）**
  ```
  客户端                                        服务器
  ① FIN →                  ---------------->
     (seq=u, 我要关闭连接)
                            <----------------  ② ACK ←
                                               (ack=u+1, 知道了)
                            <----------------  ③ FIN ←
                                               (seq=v, 我也要关闭)
  ④ ACK →                  ---------------->
     (ack=v+1, 确认关闭)
  
  ✅ TCP 连接完全关闭
  ```
  
  **说明：**
  - **FIN (Finish)** - 结束标志，表示没有数据要发送了
  - **四次挥手原因** - TCP 是全双工，双方都需要独立关闭发送通道
  - **TIME_WAIT 状态** - 客户端发送最后的 ACK 后等待 2MSL，确保服务器收到

- **TLS 握手流程（TLS 1.2 标准流程）**
  ```
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  【前置步骤：TCP 三次握手 🤝 - 已完成】
  ✅ TCP 连接已建立，开始 TLS 握手
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  客户端                                                                          服务器
  ① 生成 Client Random
  ② Client Hello →                             ---------------->
     (Client Random, 加密套件列表)
                                                                                 ③ 生成 Server Random
                                               <----------------                 ④ Server Hello ←
                                                                                    (Server Random, 选择的加密套件)
                                               <----------------                 ⑤ Certificate ←
                                                                                    (服务器证书链)
  ⑥ 验证证书 📜
     用 CA 🔑🟢 公钥验证证书签名（验签，确认服务器身份）
  
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ⏱️ 第 1 个 RTT 完成
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  【密钥交换 🔑 - RSA 和 ECDHE 的唯一区别，详见下文】
  ✅ 双方通过不同方式获得相同的 Pre-Master Secret
  ⚠️ 注意：此处密钥对用于密钥交换（加解密或密钥协商），⚠️ 不是验签
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  ⑦ 计算 Master Secret 🔐                                                        ⑧ 计算 Master Secret 🔐
     = PRF(Pre-Master Secret, Client Random, Server Random)                        = PRF(Pre-Master Secret, Client Random, Server Random)
  
  ⑨ 双方派生相同的 Session Key（对称加密密钥）
  ⑩ 加密通信 🔒                                  <--------------->
  
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ⏱️ 第 2 个 RTT 完成 - TLS 1.2 握手总共需要 2-RTT
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ```

- **TLS 1.3 握手流程（现代标准，1-RTT）**
  ```
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  【前置步骤：TCP 三次握手 🤝 - 已完成】
  ✅ TCP 连接已建立，开始 TLS 1.3 握手
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  客户端                                                                          服务器
  ① 生成 Client Random
  ② 生成临时密钥对（🔑🟢 公钥 + 🔑🔴 私钥）
  ③ Client Hello →                             ---------------->
     (Client Random, 加密套件, 客户端临时 🔑🟢 公钥)
     ⚠️ 密钥协商参数直接包含在 Client Hello 中
                                                                                 ④ 生成 Server Random
                                                                                 ⑤ 生成临时密钥对（🔑🟢 公钥 + 🔑🔴 私钥）
                                                                                 ⑥ ECDH 计算 Pre-Master Secret 🔐
                                                                                 ⑦ 计算 Master Secret 和 Session Key
                                               <----------------                 ⑧ Server Hello ←
                                                                                    (Server Random, 选择的加密套件, 服务器临时 🔑🟢 公钥)
                                               <----------------                 ⑨ Certificate ← (加密)
                                               <----------------                 ⑩ Finished ← (加密)
                                                                                    ⚠️ 证书和 Finished 已经加密
  ⑪ ECDH 计算 Pre-Master Secret 🔐
  ⑫ 计算 Master Secret 和 Session Key
  ⑬ 验证证书 📜
  ⑭ Finished →                                 ---------------->
     (加密)
  
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ⏱️ 第 1 个 RTT 完成 - TLS 1.3 握手只需 1-RTT（比 TLS 1.2 快 50%）
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  ⑮ 加密通信 🔒                                <--------------->
  ```

  **TLS 1.3 核心改进：**
  - ✅ **1-RTT 握手**：密钥协商参数直接在 Hello 消息中，减少一次往返
  - ✅ **强制 ECDHE**：移除 RSA 密钥交换，强制前向保密
  - ✅ **早期加密**：Certificate 和 Finished 消息已加密
  - ✅ **简化握手**：合并多个消息，减少握手复杂度
  - ✅ **0-RTT 重连**：已建立过连接的客户端可实现零延迟（见下文）

- **TLS 1.3 的 0-RTT 重连（可选特性）**
  ```
  客户端                                                                          服务器
  ① Client Hello →                             ---------------->
     (Session Ticket, Early Data 🚀)
     ⚠️ 直接携带加密的应用数据（如 HTTP 请求）
                                                                                 ② 立即处理 Early Data
                                               <----------------                 ③ Server Hello + Finished ←
  
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ⏱️ 0-RTT 完成 - 零延迟发送数据（Early Data 在第一个消息中就发送）
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  
  ④ 加密通信 🔒                                <--------------->
  
  ⚠️ 安全风险：重放攻击（只适用于幂等操作，如 GET 请求）
  ```

- **TLS 1.2 vs TLS 1.3 对比**

| 特性    | TLS 1.2     | TLS 1.3              |
| ----- | ----------- | -------------------- |
| 握手延迟  | 2-RTT       | 1-RTT（首次）/ 0-RTT（重连） |
| 密钥交换  | RSA / ECDHE | 仅 ECDHE（强制前向保密）      |
| 握手消息数 | 多（分散）       | 少（合并）                |
| 证书加密  | 🔴 明文       | ✅ 加密                 |
| 安全性   | 中（支持弱算法）    | 高（移除弱算法）             |
| 兼容性   | 广泛          | 现代浏览器/服务器            |
| 性能    | 较慢          | 快 50%                |

**RTT 差异的关键原因：客户端第一个消息是否携带密钥协商参数**

| 版本                | 客户端第一个消息                          | 需要等待服务器吗                          | RTT   | 原因                                 |
| ----------------- | --------------------------------- | --------------------------------- | ----- | ---------------------------------- |
| **TLS 1.2**       | Client Hello<br>（不含密钥）            | ✅ 需要等服务器发送<br>Server Key Exchange | 2-RTT | 客户端不知道服务器支持哪些曲线，<br>需要先收到服务器选择     |
| **TLS 1.3**       | Client Hello<br>（含临时 🔑🟢 公钥）     | 🔴 不需要等，<br>服务器直接完成密钥协商           | 1-RTT | 客户端猜测服务器支持的曲线<br>（通常是 x25519），直接发送 |
| **TLS 1.3 0-RTT** | Client Hello<br>（含 Early Data 🚀） | 🔴 不需要等，<br>直接发送应用数据              | 0-RTT | 使用之前会话的密钥，<br>直接加密发送 HTTP 请求       |

**核心差异：**
- **TLS 1.2**：客户端 → 等待 → 服务器 → 等待 → 完成（2 次往返）
- **TLS 1.3**：客户端（含密钥）→ 服务器 → 完成（1 次往返）
- **TLS 1.3 0-RTT**：客户端（含数据）→ 服务器立即处理（0 次往返）

- **密钥交换方式详解**

  **符号说明：🔑🟢 = 公钥（可公开） | 🔑🔴 = 私钥（保密）**

  **方式 1：RSA 密钥交换（TLS 1.2 及之前，已淘汰）**
  ```
  客户端                                    服务器
  ① 从服务器证书提取 🔑🟢 公钥
  ② 生成 Pre-Master Secret（48 字节随机数）
  ③ 使用服务器 🔑🟢 公钥加密 PMS
  ④ Client Key Exchange →  ---------------->
     (加密的 Pre-Master Secret)
                                           ⑤ 用 🔑🔴 私钥解密得到 Pre-Master Secret
  
  ✅ 双方现在都拥有相同的 Pre-Master Secret
  ```
  
  **特点：**
  - Pre-Master Secret 由客户端单方生成
  - 使用服务器证书的 RSA 🔑🟢 公钥加密传输
  - 服务器用 🔑🔴 私钥解密获取
  - **无前向保密**：服务器 🔑🔴 私钥泄露会导致所有历史会话被破解
  - **TLS 1.3 已移除**
  
  **密钥用途说明：**
  - 🔑🟢 公钥用于**加密** Pre-Master Secret（非对称加密）
  - 🔑🔴 私钥用于**解密** Pre-Master Secret（非对称解密）
  - ⚠️ 注意：这里是加解密，不是验签（验签在证书验证阶段）
  - ⚠️ 服务器证书密钥对的两种用途：
    - 证书验证阶段：CA 用 🔑🔴 私钥签名，客户端用 CA 🔑🟢 公钥验签
    - 密钥交换阶段：客户端用服务器 🔑🟢 公钥加密，服务器用 🔑🔴 私钥解密

  **方式 2：ECDHE 密钥交换（现代标准，TLS 1.3 强制）**
  ```
  客户端                                    服务器
                              <--------------  ① Server Key Exchange ←
                                                 (服务器临时 🔑🟢 公钥)
  ② 生成临时密钥对（🔑🟢 公钥 + 🔑🔴 私钥）
  ③ Client Key Exchange →    ---------------->
     (客户端临时 🔑🟢 公钥)
  
  ④ ECDH 计算 🔐                             ⑤ ECDH 计算 🔐
     自己的 🔑🔴 私钥 × 对方的 🔑🟢 公钥         自己的 🔑🔴 私钥 × 对方的 🔑🟢 公钥
     = Pre-Master Secret                      = Pre-Master Secret
  
  ✅ 双方现在都拥有相同的 Pre-Master Secret（但从未在网络上传输）
  ⚠️ 临时密钥对用完即销毁，保证前向保密
  
  【DH 算法数学原理】
  为什么双方计算出相同的值？
  - 客户端：客户端私钥(a) × 服务器公钥(g^b) = g^(a×b)
  - 服务器：服务器私钥(b) × 客户端公钥(g^a) = g^(b×a)
  - 因为乘法交换律：a×b = b×a，所以 g^(a×b) = g^(b×a)
  - 攻击者只能看到 g^a 和 g^b，无法推导出 g^(a×b)（离散对数难题）
  ```
  
  **特点：**
  - Pre-Master Secret 由双方协商计算，从未在网络上传输
  - 每次会话使用不同的临时密钥对（Ephemeral）
  - 基于椭圆曲线 Diffie-Hellman 算法
  - ✅ **前向保密**：即使服务器证书 🔑🔴 私钥泄露，历史会话仍安全（临时密钥已销毁）
  - ✅ **TLS 1.3 强制使用**
  
  **密钥用途说明：**
  - 🔑🟢 临时公钥用于**密钥协商**（交换给对方）
  - 🔑🔴 临时私钥用于**密钥协商**（计算共享密钥）
  - ⚠️ 注意：这里既不是加解密，也不是验签，是 **Diffie-Hellman 密钥协商算法**
  - ⚠️ 临时密钥对与服务器证书密钥对完全独立：
    - 证书密钥对：用于身份验证（验签）
    - 临时密钥对：用于密钥协商（每次会话生成新的，用完即销毁）

- **RSA vs ECDHE 对比**

| 特性                     | RSA 密钥交换     | ECDHE 密钥交换     |
| ---------------------- | ------------ | -------------- |
| Pre-Master Secret 生成   | 客户端单方生成      | 双方协商计算         |
| 网络传输                   | 加密后传输        | 从不传输（各自计算）     |
| 临时密钥                   | 🔴 无         | ✅ 每次会话生成新密钥对   |
| 前向保密 (Forward Secrecy) | 🔴 无         | ✅ 有            |
| 服务器私钥泄露影响              | 所有历史会话被破解    | 历史会话仍安全        |
| TLS 1.2                | ✅ 支持（不推荐）    | ✅ 支持（推荐）       |
| TLS 1.3                | 🔴 已移除       | ✅ 强制使用         |
| 当前使用率                  | <5%（仅老旧系统）   | >95%（主流）       |
| 性能                     | 较快（仅一次非对称加密） | 稍慢（需要 ECDH 计算） |
| 安全性                    | 低（无前向保密）     | 高（前向保密）        |

- **TLS 1.0、1.1、1.2、1.3 区别**
  
  - TLS 1.0 是从 SSL 3.0 标准改进而来的。
  - 目前多使用 TLS 1.2 或 1.3，推荐使用 ECDHE 算法。
  - **TLS 1.3 的核心改进：**
    - **1-RTT 握手（首次连接）**：TLS 1.2 需要 2-RTT，TLS 1.3 只需 1-RTT，减少 50% 握手延迟
      - 客户端发送 Client Hello 时直接携带密钥协商参数（支持的曲线和公钥）
      - 服务器在 Server Hello 中直接完成密钥协商，无需额外往返
    - **0-RTT 握手（重连优化）**：客户端与服务器曾经建立过连接时，可实现零延迟数据传输
      - 前提条件：
        - 成功建立过 TLS 连接，客户端持有服务器发送的 Session Ticket 或共享的 PSK（Pre-Shared Key）
        - 服务器支持 0-RTT，并向客户端声明早期数据大小（max_early_data_size）
      - 工作机制：
        - 客户端发送 Client Hello 时，直接携带 Early Data（早期数据，如 HTTP 请求）
        - 服务器收到后立即处理，无需等待握手完成
      - 安全风险：**重放攻击** - 由于 0-RTT 数据在身份验证前发送，攻击者可捕获并重放数据包多次，因此 0-RTT 只适用于幂等操作（如 GET 请求）
    - **移除不安全算法**：移除 RSA 密钥交换、SHA-1、RC4、3DES、MD5 等
    - **强制前向保密**：只支持 ECDHE 和 DHE，确保历史会话密钥不会因私钥泄露而被破解

### QUIC

https://www.infoq.cn/article/lddlsa5f21sty04li3hp

- **QUIC 协议概述**
  - QUIC 是一种建立在 UDP 协议之上，使用 TLS 1.3 协议进行安全协商，自己实现多路复用和拥塞控制的传输层协议
  - HTTP/3 基于 QUIC 协议实现
  - 完全在用户态实现，可快速迭代和优化

- **QUIC 核心优势（为什么快？）**

| 优势 | 说明 | 效果 |
|------|------|------|
| **1. 快速连接** | 1-RTT（首次）/ 0-RTT（重连） | 比 HTTPS 快 50-66% |
| **2. 无队头阻塞** | 流之间完全独立，A 流丢包不影响 B 流 | 高丢包率网络性能优异 |
| **3. 连接迁移** | 使用 Connection ID，IP/端口变化不断连 | WiFi ↔ 4G 无缝切换 |
| **4. 灵活拥塞控制** | 用户态实现，可快速部署新算法（BBR、Cubic） | 性能持续优化 |
| **5. 精确 RTT** | Packet Number 单调递增，避免重传歧义 | 更准确的性能测量 |

- **QUIC 劣势与挑战**

| 劣势 | 说明 | 影响 |
|------|------|------|
| **1. CPU 消耗大** | 用户态实现 + 全包加密，比 TCP + TLS 高 2-4 倍 | 需要更强服务器硬件 |
| **2. UDP 被阻止** | 部分防火墙/NAT 限制 UDP 流量 | 需要降级到 HTTP/2 |
| **3. 中间设备不友好** | 负载均衡器、DPI 可能不支持 | 需要升级网络设备 |
| **4. 调试困难** | 全加密，难以抓包分析 | 需要专门调试工具 |
| **5. 生态不成熟** | 库和工具链仍在完善 | 开发运维成本高 |

- **QUIC vs HTTPS 对比**

| 特性         | HTTPS (TCP + TLS) | QUIC (UDP + TLS 1.3) |
| ---------- | ----------------- | -------------------- |
| **连接建立**   | 2-3 RTT           | 1-RTT / 0-RTT        |
| **队头阻塞**   | ❌ 存在（TCP 层）       | ✅ 无（流独立）             |
| **连接迁移**   | ❌ 不支持             | ✅ 支持                 |
| **丢包恢复**   | 慢（整个连接阻塞）         | 快（只影响单个流）            |
| **拥塞控制**   | 内核实现，难更新          | 用户态，易更新              |
| **CPU 消耗** | 低（内核优化）           | 🔴 高 2-4 倍           |
| **部署难度**   | 低（广泛支持）           | 🔴 中等（UDP 限制）        |
| **调试**     | 容易（可抓包）           | 🔴 困难（全加密）           |

- **QUIC 适用场景**

| 场景类型     | ✅ 适合                    | 🔴 不适合                 |
| -------- | ----------------------- | ---------------------- |
| **网络环境** | 移动网络、高延迟、高丢包率           | 低延迟局域网                 |
| **应用类型** | 实时应用、视频会议、直播**（高频长连接）** | 数据库连接池、消息队列**（低频长连接）** |
| **连接特性** | 短连接、频繁切换网络、高频数据传输       | 低频交互、稳定网络              |
| **资源条件** | 服务器 CPU 充足              | CPU 资源受限               |
| **网络限制** | 允许 UDP 流量               | 严格限制 UDP               |

| 场景           | 连接时长 | 数据频率 | QUIC 优势                           | 是否适合 QUIC |
| ------------ | ---- | ---- | --------------------------------- | --------- |
| 视频会议         | 长    | 高频   | ✅ 无队头阻塞<br>✅ 连接迁移                 | ✅ 适合      |
| 直播           | 长    | 高频   | ✅ 无队头阻塞<br>✅ 快速恢复                 | ✅ 适合      |
| 实时游戏         | 长    | 高频   | ✅ 低延迟<br>✅ 连接迁移                   | ✅ 适合      |
| 数据库连接池       | 长    | 低频   | ❌ CPU 浪费<br>❌ 无明显优势               | 🔴 不适合    |
| WebSocket 心跳 | 长    | 低频   | ✅ 高频 WS 适合<br>❌ CPU 浪费<br>❌ 无明显优势 | 🔴 不适合    |
| 消息队列         | 长    | 低频   | ❌ CPU 浪费<br>❌ 无明显优势               | 🔴 不适合    |

| WebSocket 场景 | 数据频率        | 是否适合 QUIC | 原因            |
| ------------ | ----------- | --------- | ------------- |
| **实时游戏**     | 每秒 30-60 次  | ✅ 适合      | 高频、低延迟、需要连接迁移 |
| 实时协作编辑       | 每秒 10-50 次  | ✅ 适合      | 高频、需要无队头阻塞    |
| **股票行情**     | 每秒 10-100 次 | ✅ 适合      | 高频、实时性要求高     |
| **实时聊天（活跃）** | 每秒 1-10 次   | ✅ 适合      | 中高频、移动端需要连接迁移 |
| 实时聊天（不活跃）    | 每分钟 1-5 次   | ❌ 不适合     | 低频、TCP 足够     |
| 心跳保活         | 每 30 秒 1 次  | ❌ 不适合     | 极低频、CPU 浪费    |
| 通知推送         | 每小时几次       | ❌ 不适合     | 极低频、TCP 更好    |
| 后台任务状态       | 每分钟几次       | ❌ 不适合     | 低频、无需 QUIC 优势 |

**说明：**
- **高频长连接**（适合 QUIC）：视频会议、直播、实时游戏 - 连接时间长但数据频率高
- **低频长连接**（不适合 QUIC）：数据库连接池、WebSocket 心跳 - 连接时间长但数据频率低

- **QUIC 连接关闭机制**：使用 CONNECTION_CLOSE 帧立即关闭连接，无需像 TCP 四次挥手那样等待双方确认，实现快速断开

![QUIC](https://static001.geekbang.org/infoq/ec/ec0ce46b387488c26d88ab39f7b869ce.png)

- **HTTPS 连接延迟（TCP + TLS）**
  - **TLS 1.2**：TCP 三次握手（1 RTT）+ TLS 1.2 握手（2 RTT）= **3 RTT**
  - **TLS 1.3**：TCP 三次握手（1 RTT）+ TLS 1.3 握手（1 RTT）= **2 RTT**
  - **无法合并原因**：TCP 在内核态完成，TLS 在用户态完成，两者无法同时进行
  - ![HTTPS连接](https://static001.geekbang.org/infoq/18/183a4b3746b8019930a5c787a8026590.png)
- **QUIC 连接延迟**
  - **首次连接**：1 RTT（UDP + TLS 1.3 合并）
  - **重连（0-RTT）**：0 RTT（携带 Early Data）
  - ![QUIC连接](https://static001.geekbang.org/infoq/04/0409c295ff59bc81ca81744f9d197a9a.png)

QUIC 是一种建立在 UDP 协议之上，使用 TLS 1.3 协议进行安全协商，自己实现多路复用和拥塞控制的传输层协议，提供更快速、更可靠、更安全的传输方式。HTTP/3 基于 QUIC 协议实现。

- **Head of Line Blocking（队头阻塞）**
  
  **HTTP/1.1 的问题：**
  - 浏览器限制同一个域名下的并发连接数（通常 6 个）
  - 当请求达到最大数量时，剩余的资源需要等待其他资源请求完成后才能发起请求
  
  **HTTP/2 的改进与局限：**
  - ✅ 使用多路复用解决了 HTTP 层的队头阻塞问题（一个 TCP 连接可以并发多个请求）
  - ❌ 但在 TCP 层仍然存在队头阻塞：如果连接出现丢包，整个 TCP 连接需要等待重传，所有流都被阻塞
  - ⚠️ 在高丢包率网络下，HTTP/2 性能反而不如 HTTP/1.1（多个独立 TCP 连接）
  
  **QUIC 的彻底解决：**
  - ✅ 为每个请求流分配独立的滑动窗口
  - ✅ 流之间完全独立：A 流丢包不影响 B 流传输
  - ✅ 只有丢包的流需要重传，其他流继续传输
  
  - ![TCP连接](https://www.nxrte.com/wp-content/uploads/2023/09/640-46.png)
    ![QUCI连接](https://www.nxrte.com/wp-content/uploads/2023/09/640-47.png)

- 无歧义重传
  
  - TCP 协议使用 Sequence Number 和 ACK 确认消息有序，但是如果出现 TCP 重传，重传的 Seq Num 和原始的 Seq Num 是不变的，会引发重传歧义问题。
  - QUIC 使用了单向递增的 Packet Number 标识数据包，所以如果出现重传，重传的 Packet Number 比原始的大，避免了重传歧义问题。
  - QUIC 还引入了 Stream Offset 概念，保证应用数据的顺序。设客户端先后发送了 Pakcet N 和 Pakcet N+1，Stream Offset 分别是 x 和 x+y。如果 Packet N 丢失，引发重传，重传的 Packet Number 是 N+2，但是它的 Stream Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。



### WebSocket

WebSocket 是一个**应用层协议**，它**依赖于 TCP 协议**作为传输层协议，同时**启动时还需要依赖 HTTP 协议完成连接**的“升级”握手，WS 升级以后 HTTP  协议终止，不在是 HTTP 请求-响应模式，然后使用 WebSocket 定义的数据帧格式直接在 TCP 上传输，不使用 HTTP 的协议格式，实现真正的**双全工模式**。

WS 运行于 TCP 传输协议之上，使用 TCP 提供可靠，面向连接的服务。

**WebSocket 握手流程：**

```
客户端                                                    服务器
  |                                                         |
  | TCP 三次握手成功，建立连接                                  |
  |                                                         |
  | HTTP 请求 (Upgrade: websocket)                          |
  | ------------------------------------------------------> |
  |                                                         |
  |                      HTTP 101 Switching Protocols      |
  | <------------------------------------------------------ |
  |                                                         |
  | TCP 连接上协议升级为 WebSocket                             |
  |                                                         |
  | <====== 双向实时通信（WebSocket 协议格式）======>          |
  |                                                         |
```

**ALB WebSocket 流程：**

```
客户端                        ALB                      后端 EC2 服务器
  |                            |                              |
  | HTTP (Upgrade: websocket)  |                              |
  | -------------------------> |                              |
  |                            |                              |
  |   HTTP 101 Switching       |                              |
  | <------------------------- |                              |
  |                            |                              |
  |                            | TCP 长连接                    |
  |                            | <-------------------------> |
  |                            |                              |
  | <======== 数据帧双向透明转发 ========>                      |
  |                            |                              |
```

| 名称  | 组成字段              | 作用            | 备注            |
|:--- |:----------------- |:------------- | ------------- |
| 三元组 | 协议、本地IP、本地端口      | 标识主机上的通信端点    | 只能标识单个通信端点    |
| 四元组 | 源IP、源端口、目的IP、目的端口 | 标识网络中单向数据流    | TCP 会话跟踪使用四元组 |
| 五元组 | 三元组+目的IP、目的端口、协议  | 唯一标识网络中完整通信连接 |               |
| 七元组 | 五元组+服务类型、接口索引     | 更精细的网络流量和策略管理 |               |

### UDP

UDP 协议原理：

- **无连接性**：UDP是无连接协议，通信双方不需要建立连接即可直接发送数据包。
- **简单高效**：UDP头部仅8字节，包含源端口、目标端口、长度和校验和，开销极小。
- **不可靠传输**：UDP不提供数据重传、确认、排序功能，数据包可能丢失、重复或乱序。可靠性由应用层负责。
- **面向消息**：UDP的数据包保留应用层消息边界，消息作为独立数据报传输。

UDP 工作流程：

- **发送端处理**：应用层将数据传给UDP，UDP封装头部生成UDP数据报，通过IP发送。无需建立连接。
- **接收端处理**：IP协议将数据报转给UDP，UDP验证校验和，然后将数据交给对应端口的应用。
- **无状态**：UDP协议栈不存储连接状态，不保证数据顺序或完整性。丢失与否由应用自行检测。

##### 与 TCP 的区别

| 特性    | UDP       | TCP               |
|:----- |:--------- |:----------------- |
| 连接性   | 无连接       | 面向连接              |
| 传输可靠性 | 不保证       | 保证顺序、可靠传输         |
| 头部开销  | 8字节       | 20字节              |
| 传输速度  | 快，低延迟     | 稍慢，但功能全面          |
| 应用场景  | 实时性、广播、多播 | 文件传输、网页加载等需可靠传输场景 |

### DNS

CNAME 是域名别名

DNS Adress Record 是域名的 IPv4 地址

DNS AAAA 是 IPv6 地址

**DNS 查询优先级：浏览器缓存 > 操作系统缓存 > hosts 文件 > DNS 服务器**

hosts 文件只是配置了域名和 ip 的映射关系，如果浏览器输入的地址在 hosts 文件有记录，则直接返回 ip

**浏览器 → 递归 DNS → (根 DNS → 顶级域 DNS → 权威 DNS)**

- **DNS 完整查询流程图**
  ```
  用户输入 www.example.com
      ↓
  ① 浏览器缓存（命中 → 直接使用）
      ↓ 未命中
  ② 操作系统缓存（命中 → 直接使用）
      ↓ 未命中
  ③ hosts 文件（/etc/hosts 或 C:\Windows\System32\drivers\etc\hosts）
      ↓ 未命中
  ④ 递归 DNS 服务器（Local DNS，如 8.8.8.8、1.1.1.1、ISP 提供）
      ↓ 缓存未命中，开始递归查询
  ⑤ 根 DNS 服务器（13 个根服务器，如 a.root-servers.net）
      ↓ 返回：".com 的 DNS 在 a.gtld-servers.net"
  ⑥ 顶级域 DNS 服务器（.com DNS）
      ↓ 返回："example.com 的权威 DNS 在 ns1.example.com"
  ⑦ 权威 DNS 服务器（example.com 的权威 DNS）
      ↓ 返回："www.example.com 的 IP 是 93.184.216.34"
  ⑧ 递归 DNS 缓存结果（TTL 时间内有效）
      ↓
  ⑨ 返回 IP 给浏览器
      ↓
  ⑩ 浏览器连接 93.184.216.34
  ```

- **实际查询例子（查询 www.google.com）**
  ```
  1. 浏览器 → 递归 DNS (8.8.8.8)
     "www.google.com 的 IP 是什么？"
  
  2. 递归 DNS 检查缓存 → 未命中
  
  3. 递归 DNS → 根 DNS (a.root-servers.net)
     "谁管理 .com？"
     根 DNS 回复："a.gtld-servers.net"
  
  4. 递归 DNS → .com DNS (a.gtld-servers.net)
     "谁管理 google.com？"
     .com DNS 回复："ns1.google.com"
  
  5. 递归 DNS → 权威 DNS (ns1.google.com)
     "www.google.com 的 IP 是什么？"
     权威 DNS 回复："142.250.185.46, TTL=300"
  
  6. 递归 DNS 缓存结果（300 秒）
  
  7. 递归 DNS → 浏览器
     "142.250.185.46"
  ```

- **递归 DNS**
  - 浏览器地址 **=>** 浏览器缓存（如果缓存命中 ip，直接使用）**=>** 操作系统缓存（查询系统层缓存）**=>** hosts 文件 **=>** DNS 服务器查询
  - **DNS 服务器查询流程**
    - 本地递归 DNS 服务器（Local DNS 查询）一般由 ISP 或企业网络提供，未命中则查询根 DNS **=>** 
      根 DNS 服务器查询 **=>** 
      顶级 DNS 服务器（管理 .com, .net, .cn, .org 等顶级域名） **=>** 
      权威 DNS（存储最终解析信息，A，CNAME，MX 等记录）
  - **TTL（Time To Live）**：权威 DNS 返回的记录包含 TTL 值，递归 DNS 会缓存该记录直到 TTL 过期
- **权威 DNS**
  - 主权威 DNS，拥有域名数据库的写权限，辅助权威 DNS，从主服务器同步数据，提供冗余和负载均衡

#### 权威 DNS 与递归 DNS 的主要区别与安全差异

##### 本质区别：**权威 DNS 存域名数据，递归 DNS 查找域名数据。**

| 角色     | 职责        | 数据来源       | 是否缓存         |
| ------ | --------- | ---------- | ------------ |
| 权威 DNS | 存储域名的权威记录 | 域名所有者配置    | ❌ 不缓存（实时数据）  |
| 递归 DNS | 代理查询 + 缓存 | 从权威 DNS 获取 | ✅ 缓存（TTL 时间） |
| 用户     | 发起查询      | 从递归 DNS 获取 | ✅ 缓存（浏览器/OS） |

| 方面           | 权威 DNS 服务器                 | 递归 DNS 服务器                            |
| :----------- | :------------------------- | :------------------------------------ |
| **功能定位**     | 存储特定域名权威记录，**提供最终解析结果**    | 负责代表客户端**递归查询，缓存结果**加速后续访问            |
| **数据来源**     | 直接**管理该域名的真实 DNS 资源记录**    | 通过递归请求权威 DNS 和其它 DNS 缓存服务器收集信息        |
| **缓存机制**     | **无缓存**，实时提供权威数据           | 具有缓存机制，缓存查询结果以减少查询次数                  |
| **安全风险**     | 面临数据篡改、权威服务器攻击等威胁          | 主要**面临缓存投毒、安全隐私泄露、DDoS 及劫持等威胁**       |
| **攻击防护**     | **通过 DNSSEC 确保数据完整性**，访问控制 | 需防止缓存投毒、实现DNS查询加密（DNS over HTTPS/TLS） |
| **服务对象**     | 递归服务器和直接访问该域的客户端           | 终端用户设备及其他 DNS 服务器                     |
| **数据一致性**    | 由域管理员维护，依靠 SOA 和区域传送保持同步   | 依赖权威 DNS，数据可能因缓存失效而滞后                 |
| **对安全隐私的影响** | 相对较低，避免被攻击用作流量反射           | 较高，可能泄露大量用户查询信息                       |

##### 选择何时使用（或接触）哪种服务器

| 用户类型        | 通常使用的DNS服务器         | 理由说明                     |
|:----------- |:------------------- |:------------------------ |
| 普通互联网终端用户   | 递归 DNS 服务器          | 简化操作，无需了解权威DNS，获取DNS解析结果 |
| 域名持有者和托管服务器 | **权威 DNS 服务器**      | 管理域名数据，提供权威解析答案          |
| 网络设备和DNS运营商 | 递归 DNS 和权威 DNS 都会使用 | 递归用于递归查询和缓存，权威用于数据真实来源   |

##### 域名持有者配置权威 DNS 的完整流程

**场景：你拥有域名 myapp.com，需要让用户能访问你的服务**

**步骤 1：购买域名**
```
在域名注册商购买：myapp.com
```

**步骤 2：选择权威 DNS 服务商**

| 服务商 | 特点 | 适用场景 |
|--------|------|---------|
| AWS Route 53 | 全球分布、高可用、与 AWS 集成 | 企业级应用 |
| Cloudflare DNS | 免费、快速、DDoS 防护 | 中小型网站 |
| 阿里云 DNS | 国内优化、价格低 | 国内业务 |
| 腾讯云 DNSPod | 国内优化、免费版功能强 | 国内业务 |
| 域名注册商自带 | 简单、无需额外配置 | 个人网站 |

**步骤 3：配置权威 DNS 记录**
```
在 AWS Route 53 创建 Hosted Zone：myapp.com

配置 DNS 记录：
  记录类型    主机名              值                TTL
  A          myapp.com          1.2.3.4           300
  A          www.myapp.com      1.2.3.4           300
  A          api.myapp.com      5.6.7.8           300
  CNAME      cdn.myapp.com      cdn.cloudflare.com 300
  MX         myapp.com          mail.myapp.com    300
  TXT        myapp.com          "v=spf1 ..."      300
```

**步骤 4：在域名注册商配置 NS 记录**
```
Route 53 分配的 Name Servers（NS 记录）：
  ns-1234.awsdns-12.org
  ns-5678.awsdns-34.com
  ns-9012.awsdns-56.net
  ns-3456.awsdns-78.co.uk

在域名注册商（如 GoDaddy）配置：
  myapp.com 的 DNS 服务器 → 填入上面 4 个 NS 记录

这告诉全世界："myapp.com 的权威 DNS 在 AWS Route 53"
```

**步骤 5：DNS 传播和验证**
```bash
# 等待 DNS 传播（24-48 小时）

# 验证 NS 记录
dig myapp.com NS
# 应该返回：ns-1234.awsdns-12.org 等

# 验证 A 记录
dig www.myapp.com
# 应该返回：1.2.3.4

# 直接查询权威 DNS
dig @ns-1234.awsdns-12.org www.myapp.com
# 应该返回：1.2.3.4
```

**用户访问你的服务的完整流程**
```
用户输入：www.myapp.com
    ↓
① 用户浏览器 → 递归 DNS (8.8.8.8)
    ↓
② 递归 DNS → 根 DNS："谁管理 .com？"
    ↓
③ 递归 DNS → .com DNS："谁管理 myapp.com？"
   回复："ns-1234.awsdns-12.org"（你配置的权威 DNS）
    ↓
④ 递归 DNS → 你的权威 DNS (Route 53)："www.myapp.com 的 IP？"
   回复："1.2.3.4"
    ↓
⑤ 递归 DNS 缓存结果（TTL=300 秒）
    ↓
⑥ 递归 DNS → 用户浏览器："1.2.3.4"
    ↓
⑦ 用户浏览器连接 1.2.3.4
```

**关键概念**

| 概念 | 说明 | 你的操作 |
|------|------|---------|
| **域名注册商** | 购买域名的地方 | 购买域名 + 配置 NS 记录 |
| **权威 DNS 服务商** | 托管 DNS 记录的地方 | 配置 A/CNAME/MX 等记录 |
| **NS 记录** | 指向权威 DNS 服务器 | 在注册商配置，指向权威 DNS |
| **A 记录** | 域名指向的 IP 地址 | 在权威 DNS 配置 |
| **TTL** | DNS 记录缓存时间 | 在权威 DNS 配置（秒） |
| **递归 DNS** | 用户使用的 DNS | 无需配置（用户自动使用） |

------

#### HTTPDNS 协议

**HTTPDNS（HTTP-based DNS）是一种基于 HTTP 协议的域名解析机制**

**核心原理：**
- 传统 DNS：客户端 --UDP 53--> 递归 DNS --UDP 53--> 权威 DNS
- HTTPDNS：客户端 --HTTP/HTTPS--> HTTPDNS 服务器 --UDP 53--> 权威 DNS

**关键改进：**
- **客户端 → HTTPDNS 服务器**：使用 HTTP/HTTPS（80/443 端口），加密传输，防止劫持
- **HTTPDNS 服务器 → 权威 DNS**：仍使用传统 DNS 协议（UDP/TCP 53 端口）

**传统 DNS vs HTTPDNS 对比**

| 维度 | 传统 DNS | HTTPDNS |
|------|---------|---------|
| **协议** | UDP/TCP（53 端口） | HTTP/HTTPS（80/443 端口） |
| **数据格式** | DNS 报文（二进制） | JSON/XML（文本） |
| **是否加密** | ❌ 明文 | ✅ HTTPS 加密 |
| **DNS 劫持** | ⚠️ 容易被劫持 | ✅ 防止劫持 |
| **缓存污染** | ⚠️ 可能被污染 | ✅ 不会被污染 |
| **解析精度** | ⚠️ 可能不准确 | ✅ 精确（智能调度） |
| **兼容性** | ✅ 广泛支持 | ⚠️ 需要 SDK 支持 |
| **部署成本** | ✅ 低（系统自带） | ⚠️ 高（需要集成） |

**HTTPDNS 使用场景与适用性**

| 场景         | 传统 DNS 问题                                                                             | HTTPDNS 解决方案     | 效果      | 是否适合   |
| ---------- | ------------------------------------------------------------------------------------- | ---------------- | ------- | ------ |
| **移动 APP** | 运营商 DNS 劫持，返回错误 IP                                                                    | HTTPS 加密，无法劫持    | ✅ 防劫持   | ✅ 强烈推荐 |
| **跨网访问**   | 电信用户访问联通服务器，解析不准确                                                                     | 智能调度，返回最优 IP     | ✅ 提升速度  | ✅ 推荐   |
| **弱网环境**   | UDP 丢包率高，DNS 解析失败                                                                     | HTTP 重试机制，可靠性高   | ✅ 提升成功率 | ✅ 推荐   |
| **安全要求高**  | DNS 明文传输，隐私泄露                                                                         | HTTPS 加密，保护隐私    | ✅ 安全合规  | ✅ 推荐   |
| **CDN 加速** | 传统 DNS 基于递归 DNS 位置调度，精度有限<br>（CloudFront 等支持 EDNS Client Subnet 可改善，<br>但依赖递归 DNS 支持） | 基于用户真实 IP 返回最近节点 | ✅ 更精确调度 | ✅ 推荐   |
| **灰度发布**   | 传统 DNS 无法按用户分组                                                                        | 根据用户 ID 返回不同 IP  | ✅ 灵活调度  | ✅ 推荐   |
| **浏览器网页**  | -                                                                                     | 浏览器不支持 HTTPDNS   | -       | ❌ 不适合  |
| **内网应用**   | -                                                                                     | 无劫持风险，无需 HTTPDNS | -       | ❌ 不适合  |
| **稳定网络**   | -                                                                                     | 传统 DNS 已足够       | -       | ❌ 不适合  |
| **简单静态网站** | -                                                                                     | 开发成本高，收益低        | -       | ❌ 不适合  |
| **开发成本敏感** | -                                                                                     | 需要集成 SDK，有学习成本   | -       | ❌ 不适合  |

**HTTPDNS 服务商对比**

| 类型             | 服务商            | API 示例                     | 特点            | 是否需要注册 |
| -------------- | -------------- | -------------------------- | ------------- | ------ |
| **商业 HTTPDNS** | 阿里云 HTTPDNS    | https://httpdns.aliyun.com | 智能调度、SDK、统计分析 | ✅ 需要   |
| **商业 HTTPDNS** | 腾讯云 HTTPDNS    | https://119.29.29.98/d     | 智能调度、SDK、免费额度 | ✅ 需要   |
| **公共 DoH**     | Cloudflare DoH | https://1.1.1.1/dns-query  | 全球服务，隐私保护     | 🔴 不需要 |
| **公共 DoH**     | Google DoH     | https://8.8.8.8/dns-query  | 全球服务，标准协议     | 🔴 不需要 |

**说明：**
- **商业 HTTPDNS**：需要注册账号，提供 SDK、控制台、智能调度、统计分析等功能，按量收费
- **公共 DoH**：完全免费，无需注册，任何人都可以使用，但无定制功能和技术支持

**云服务商 HTTPDNS 支持情况**

| 云服务商  | 商业 HTTPDNS 服务 | 说明                       |
| ----- | ------------- | ------------------------ |
| 阿里云   | ✅ 有           | 国内主流，功能完善                |
| 腾讯云   | ✅ 有           | 国内主流，免费额度大               |
| AWS   | ❌ 无           | 可使用 Route 53 + 自建        |
| GCP   | ❌ 无           | 提供公共 DoH（8.8.8.8），但非商业服务 |
| Azure | ❌ 无           | 可使用 Azure DNS + 自建       |

#### TCP（全双工模式）

TCP 是全双工（Full-Duplex）通信协议，连接建立后双方可以同时发送和接收数据，互不干扰。每个方向都有独立的序列号（Sequence Number）和确认号（Acknowledgment Number），实现可靠的双向数据传输。

![TCP](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b9013236e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

![TCP握手](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b92f7503f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

![TCP挥手](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b93024c48~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

---
